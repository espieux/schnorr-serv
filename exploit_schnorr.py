import requests
from Crypto.Util.number import inverse
from concurrent.futures import ThreadPoolExecutor, as_completed

URL = 'http://localhost:5000/vulnerable-proof'
G = 2
NUM_THREADS = 4

def check_k(g, k, p, r, s, e, y):
    calculated_r = pow(g, k, p)
    print(f"Expected r: {r}, Calculated r: {calculated_r}")

    if calculated_r == r:
        x = ((s - k) * inverse(e, p-1)) % (p-1)
        calculated_y = pow(g, x, p)
        print(f"Expected y: {y}, Calculated y: {calculated_y}")

        if calculated_y == y:
            return True, k, x
    return False, k, None


def find_k_and_compute_x(proof):
    p = int(proof['p'])
    y = int(proof['y'])
    g = int(proof['g'])
    e = int(proof['e'])
    s = int(proof['s'])
    r = int(proof['r'])

    print(f"Received proof: p={p}, y={y}, g={g}, e={e}, s={s}, r={r}")

    with ThreadPoolExecutor(max_workers=NUM_THREADS) as executor:
        futures = {executor.submit(check_k, g, k, p, r, s, e, y): k for k in range(p)}
        tried = 0
        print(f"Trying {p} possibilities...", end='\r', flush=True)

        for future in as_completed(futures):
            tried += 1
            success, k, x = future.result()
            print(f"Tried {tried} of {p} possibilities...", end='\r', flush=True)
            
            if success:
                print(f"\nSuccessfully recovered k={k} and x={x}")
                return k, x

    print("\nFailed to recover secret key")
    return None, None

def get_proof():
    try:
        response = requests.get(URL)
        response.raise_for_status()  # Raises HTTPError for bad responses
        return response.json()
    except requests.RequestException as e:
        print(f"Failed to fetch proof: {e}")
        return None

def test_single_k():
    proof = get_proof()
    if not proof:
        print("No proof available, terminating test.")
        return

    p = int(proof['p'])
    y = int(proof['y'])
    g = int(proof['g'])
    e = int(proof['e'])
    s = int(proof['s'])
    r = int(proof['r'])
    k = 123  # example k value for testing

    result, k, x = check_k(g, k, p, r, s, e, y)
    if result:
        print(f"Successfully recovered k={k} and x={x}")
    else:
        print("Test failed or incorrect k")


if __name__ == "__main__":
    test_single_k()
    # proof = get_proof()
    # find_k_and_compute_x(proof)
