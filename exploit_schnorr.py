import requests
from Crypto.Util.number import inverse
from concurrent.futures import ThreadPoolExecutor, as_completed

URL = 'http://localhost:5000/vulnerable-proof'
G = 2
NUM_THREADS = 16 # Number of threads to use for parallel processing

def check_k(g, k, p, r, s, e, y):
    calculated_r = pow(g, k, p)
    print(f"Expected r: {r}, Calculated r: {calculated_r}")

    if calculated_r == r:
        x = ((s - k) * inverse(e, p-1)) % (p-1)
        calculated_y = pow(g, x, p)
        print(f"Expected y: {y}, Calculated y: {calculated_y}")

        if calculated_y == y:
            return True, k, x
    return False, k, None


def find_k_and_compute_x(proof):
    p = int(proof['p'])
    y = int(proof['y'])
    g = int(proof['g'])
    e = int(proof['e'])
    s = int(proof['s'])
    r = int(proof['r'])

    print(f"Received proof: p={p}, y={y}, g={g}, e={e}, s={s}, r={r}")

    # EXPLANATION
    # Understanding the Issue with Identical e
    # When the challenge e remains constant in a cryptographic scheme like Schnorr's:
    #
    # - Repeated Nonce Vulnerability: Typically, exploiting a repeated nonce involves having different e values, where:
    #     s1 = k + e1 * x mod (p - 1)
    #     s2 = k + e2 * x mod (p - 1)
    #   Here, subtracting these two equations would normally eliminate k, allowing you to solve for x
    #   because Δe = e1 - e2 would be non-zero.
    #
    # - No Variable e: However, with e being the same in all proofs, Δe becomes zero, which means
    #   you can't simplify the equations to solve for x as described above.

    # Since the typical method of exploiting difference in the expected and calculated r values is not possible, 
    # I will try to recover the secret key x by brute-forcing the nonce k.
    # Even thought I tried, it is still too computationally expensive for me to brute-force the nonce k.

    with ThreadPoolExecutor(max_workers=NUM_THREADS) as executor:
        futures = {executor.submit(check_k, g, k, p, r, s, e, y): k for k in range(p)}
        tried = 0
        print(f"Trying {p} possibilities...", end='\r', flush=True)

        for future in as_completed(futures):
            tried += 1
            success, k, x = future.result()
            print(f"Tried {tried} of {p} possibilities...", end='\r', flush=True)
            
            if success:
                print(f"\nSuccessfully recovered k={k} and x={x}")
                return k, x

    print("\nFailed to recover secret key")
    return None, None

def get_proof():
    try:
        response = requests.get(URL)
        response.raise_for_status()  # Raises HTTPError for bad responses
        return response.json()
    except requests.RequestException as e:
        print(f"Failed to fetch proof: {e}")
        return None

if __name__ == "__main__":
    proof = get_proof()
    find_k_and_compute_x(proof)
